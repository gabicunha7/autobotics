<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Autobotics | Dashboard</title>

  <link rel="stylesheet" href="css/sidebar.css" />
  <link rel="stylesheet" href="css/dash_alertas_tempo_real.css" />

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="js/rotaDash.js"></script>

  <!-- ANYCHART (Heatmap novo) -->
  <script src="https://cdn.anychart.com/releases/8.11.0/js/anychart-core.min.js"></script>
  <script src="https://cdn.anychart.com/releases/8.11.0/js/anychart-heatmap.min.js"></script>
</head>

<body>

  <aside>
    <section>
      <section class="menu-container">
        <img class="img-logo-curta" src="assets/logo/LOGO_CURTA.png" alt="">
        <h1>MENU</h1>

        <div class="paginas-container">
          <div class="menu-dropdown-container">
            <button class="a-pagina" onclick="menu(event)" id="selecionado" tag="agora">
              <img class="icon-pagina" src="assets/icones/dash_icon.png" alt="">
              Dashboards
              <img class="icon-pagina" src="assets/icones/arrow_down.png" alt="">
            </button>
            <div class="menu-dropdown-items" id="menuDropdown"></div>
          </div>

          <a class="a-pagina" href="alerta.html">
            <img class="icon-pagina" src="assets/icones/alerta_icon.png" alt="">
            Alertas
          </a>
          <a class="a-pagina" href="parametros.html">
            <img class="icon-pagina" src="assets/icones/parametros_icon.png" alt="">
            Parâmetros
          </a>
          <a class="a-pagina" href="setor.html">
            <img class="icon-pagina" src="assets/icones/setor_icon.png" alt="">
            Setores
          </a>
          <a class="a-pagina" href="controladores.html">
            <img class="icon-pagina" src="assets/icones/controlador_icon.png" alt="">
            Controladores
          </a>
          <a class="a-pagina" href="funcionario.html">
            <img class="icon-pagina" src="assets/icones/userImg.png" alt="">
            Funcionários
          </a>
        </div>
      </section>

      <a href="index.html">
        <button id="btn-sair" onclick="limparSessao()">
          <img class="icon-sair" src="assets/icones/sair_icon.png" alt="">
          Sair
        </button>
      </a>
    </section>
  </aside>

  <section class="container-content">

    <div class="div-superior">
      <div class="div-filtro">
        <div class="div_select">
          <p>Controlador:</p>
          <select>
            <option>Todos</option>
          </select>
        </div>
      </div>

      <div class="div-usuario">
        <div class="div-img-usuario">
          <img src="assets/icones/foto_usuario.png" alt="">
        </div>
        <div>
          <h6 id="nome-usuario">Usuário</h6>
          <p id="email-usuario">usuario@email.com</p>
        </div>
      </div>
    </div>

    <div class="div-info-conteudo">
      <div>
        <h3 id="titulo-dashboard">Dashboard de Alertas em Tempo Real</h3>
        <p id="label-setor" style="margin-top:4px; color:#555; font-size:0.95rem">Setor: —</p>
      </div>
      <p id="data_atual"></p>
    </div>

    <div class="div-conteudo">
      <div class="dashboard-wrapper">

        <div class="card area-kpi1">
<div class="kpi-tooltip-container">
  <span class="kpi-tooltip-label">Legenda &#9432;</span>
  <div class="kpi-tooltip">
    <p><span class="tooltip-green"></span> Verde: Quantidade esperada de alertas</p>
    <p><span class="tooltip-yellow"></span> Amarelo: Quantidade anormal de alertas</p>
    <p><span class="tooltip-red"></span> Vermelho: Quantidade muito elevada de alertas</p>
  </div>
</div>

          <h4>Alertas Ativos</h4>
          <div class="kpi_dashboard">
            <div class="kpi-total-line" id="kpi_total_line">
              Total: <span id="kpi_total">0</span>
            </div>
            <div class="kpi-line">Médio: <span id="kpi_medio">0</span></div>
            <div class="kpi-line">Crítico: <span id="kpi_critico">0</span></div>
          </div>
        </div>

        <div class="card area-kpi2">
          <h4>Alertas Resolvidos (hoje)</h4>
          <div class="kpi_dashboard">
            <p id="kpi_resolvidos">0</p>
          </div>
        </div>

        <div class="card area-feed">
          <h2>Feed de Alertas</h2>
          <div class="feed" id="feed_area"></div>
        </div>

        <div class="card area-chart">
          <h2>Alertas por Componente</h2>
          <canvas id="grafico_componentes" class="canvas-full"></canvas>
        </div>

        <div class="card area-heatmap">
          <h2>Estabilidade dos Controladores</h2>
          <div id="container" style="height:100%; width:100%; min-height:260px;"></div>
        </div>

      </div>
    </div>

  </section>

  <script>
async function lerJsonS3() {
  try {
    const resposta = await fetch('/s3RouteAlertasTempoReal/dados/ultimo');
    const texto = await resposta.text();

    if (!resposta.ok) {
      console.error('Erro na requisição /s3RouteHistoricoAlerta/dados/ultimo', resposta.status, texto);
      const msgEl = document.getElementById('erroBuscaS3');
      if (msgEl) msgEl.textContent = 'Erro do servidor ao buscar dados: ' + (texto || resposta.status);
      return null;
    }

    let data;
    try {
      data = JSON.parse(texto);
    } catch (e) {
      console.warn('Resposta não é JSON, usando texto:', texto);
      data = texto;
    }

    console.log('ultimo JSON do bucket (histórico de alertas):', data);
    sessionStorage.JSON_ALERTA = JSON.stringify(data);
    return data;

  } catch (err) {
    console.error('Erro ao buscar último arquivo do S3:', err);
    const msgEl = document.getElementById('erroBuscaS3');
    if (msgEl) msgEl.textContent = 'Falha ao buscar dados do S3: ' + (err.message || err);
    return null;
  }
}

lerJsonS3();

document.getElementById('nome-usuario').innerText = sessionStorage.NOME_USUARIO || 'Usuário';
document.getElementById('email-usuario').innerText = sessionStorage.EMAIL_USUARIO || 'usuario@email.com';

// Preenche data atual
function exibirDataAtual() {
  const dataAtual = new Date();
  const dia = String(dataAtual.getDate()).padStart(2, '0');
  const mes = String(dataAtual.getMonth() + 1).padStart(2, '0');
  const ano = dataAtual.getFullYear();
  const dataFormatada = `Data: ${dia}/${mes}/${ano}`;
  document.getElementById('data_atual').innerText = dataFormatada;
}

exibirDataAtual();

function normalizaSemAcento(s) {
  return (s || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// helper para normalização geral
function norm(s) {
  return normalizaSemAcento(s || "").toUpperCase().trim();
}

// Normaliza serial/maquina para comparação: extrai dígitos e remove zeros à esquerda.
function normalizeSerialForCompare(v) {
  if (v === undefined || v === null) return '';
  const s = String(v);
  const digits = s.replace(/\D/g, '');
  if (digits.length) return digits.replace(/^0+/, '') || '0';
  return s.trim().toLowerCase();
}

function serialEquals(a, b) {
  return normalizeSerialForCompare(a) === normalizeSerialForCompare(b);
}

// Parse de datas recebidas do JSON de forma tolerante.
// Corrige offsets de timezone no formato +HHMM / -HHMM para +HH:MM / -HH:MM
function parseDateString(s) {
  if (!s && s !== 0) return new Date(NaN);
  if (s instanceof Date) return s;
  if (typeof s !== 'string') return new Date(s);

  let t = s.trim();

  // se terminar com +HHMM ou -HHMM, transforma em +HH:MM
  t = t.replace(/([+-]\d{2})(\d{2})$/, '$1:$2');

  const dt = new Date(t);
  if (DEBUG_HEATMAP && isNaN(dt.getTime())) {
    console.debug('[HEATMAP] parseDateString falhou para:', s, '-> tried:', t);
  }
  return dt;
}

let activeAlerts = new Map();
let ultimoLoteAlertas = [];
let controladoresSetor = [];
let heatmapChart = null;
let graficoComponentes = null;
let controladorFiltroSelecionado = "Todos";
const DEBUG_HEATMAP = true;

async function buscarControladores() {
  try {
    const resposta = await fetch("/setores/buscarControladores", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        setor: sessionStorage.getItem("SETOR_USUARIO"),
        empresa: sessionStorage.getItem("EMPRESA_USUARIO")
      })
    });
    if (!resposta.ok) throw "Erro ao buscar controladores do setor.";
    const dados = await resposta.json();
    return dados;
  } catch (erro) {
    console.error(erro);
    return [];
  }
}

function criarGraficoComponentes() {
  const ctx = document.getElementById('grafico_componentes').getContext('2d');
  graficoComponentes = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'CPU', data: [], borderColor: 'grey', backgroundColor: 'transparent', tension: 0.2, fill: false, pointRadius: 3 },
        { label: 'RAM', data: [], borderColor: '#890B59', backgroundColor: 'transparent', tension: 0.2, fill: false, pointRadius: 3 },
        { label: 'Disco', data: [], borderColor: '#0000FF', backgroundColor: 'transparent', tension: 0.2, fill: false, pointRadius: 3 }
      ]
    },
    options: {
      responsive: true,
      plugins: { legend: { position: 'top' } },
      scales: {
        x: { display: true, title: { display: true, text: 'Hora' } },
        y: { beginAtZero: true, ticks: { stepSize: 1 } }
      }
    }
  });
}

function formatHoraFrom(item) {
  const dtString = item.ConcluidoEm || item.CriadoEm || item.firstSeen;
  if (!dtString) return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  const dt = parseDateString(dtString);
  return isNaN(dt.getTime())
    ? new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
    : dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function makeAlertKey(item) {
  if (item.ID) return String(item.ID);
  if (item.Key) return String(item.Key);
  const maquina = item.Descricao?.Maquina || '';
  const summary = item.Summary || '';
  const criado = item.CriadoEm ? String(item.CriadoEm) : (item.firstSeen || '');
  return `${maquina}||${summary}||${criado}`;
}

function atualizarTituloDashboard() {
  const titulo = document.getElementById('titulo-dashboard');
  if (controladorFiltroSelecionado === "Todos") {
    titulo.innerText = "Dashboard de Alertas em Tempo Real - Todos os Controladores";
  } else {
    titulo.innerText = `Dashboard de Alertas em Tempo Real - Controlador ${controladorFiltroSelecionado}`;
  }
}

function popularSelectControladores() {
  const select = document.querySelector('.div-filtro select');
  select.innerHTML = '';

  const optionTodos = document.createElement('option');
  optionTodos.value = "Todos";
  optionTodos.text = "Todos";
  select.appendChild(optionTodos);

  controladoresSetor.forEach(ctrl => {
    const option = document.createElement('option');
    option.value = ctrl.numero_serial;
    option.text = "Controlador " + ctrl.numero_serial;
    select.appendChild(option);
  });

  select.value = "Todos";
  atualizarTituloDashboard();

  select.addEventListener('change', (e) => {
    controladorFiltroSelecionado = e.target.value;
    atualizarTituloDashboard();
    usarDadosReais(ultimoLoteAlertas);
  });
}

function atualizarKPI(ativos) {
  const total = ativos.length;

  const medio = ativos.filter(a =>
    ["MEDIO", "MÉDIO"].includes(
      norm(a.Descricao?.Criticidade || '')
    )
  ).length;

  const critico = ativos.filter(a =>
    ["CRITICO", "CRÍTICO"].includes(
      norm(a.Descricao?.Criticidade || '')
    )
  ).length;

  document.getElementById("kpi_total").innerText = total;
  document.getElementById("kpi_medio").innerText = medio;
  document.getElementById("kpi_critico").innerText = critico;

  const kpiTotalLine = document.getElementById("kpi_total_line");

  if (controladorFiltroSelecionado === "Todos") {
    if (total <= 7) kpiTotalLine.style.backgroundColor = "#4CAF50";
    else if (total <= 15) kpiTotalLine.style.backgroundColor = "#f4b400";
    else kpiTotalLine.style.backgroundColor = "#E71831";
  } else {
    if (total === 0) kpiTotalLine.style.backgroundColor = "#4CAF50";
    else if (total === 1) kpiTotalLine.style.backgroundColor = "#f4b400";
    else kpiTotalLine.style.backgroundColor = "#E71831";
  }
}

function usarDadosReais(dados) {
  const setorUsuarioRaw = sessionStorage.getItem("SETOR_USUARIO") || "";
  const setorUsuarioNorm = setorUsuarioRaw ? norm(setorUsuarioRaw) : null;

  let resolvidosHoje = [];

  dados.forEach(item => {
    const payloadKey = makeAlertKey(item);
    const existing = activeAlerts.get(payloadKey) || {};
    const criadoEm = item.CriadoEm || existing.CriadoEm || new Date().toISOString();

    if (item.Status === 'Aberto') {
      activeAlerts.set(payloadKey, {
        ID: item.ID,
        Key: item.Key,
        Status: 'Aberto',
        Descricao: item.Descricao || existing.Descricao || {},
        CriadoEm: criadoEm,
        Summary: item.Summary || existing.Summary || '',
        firstSeen: existing.firstSeen || new Date().toISOString()
      });
    } else if (item.Status === 'Concluído') {
      resolvidosHoje.push({
        ID: item.ID,
        Key: item.Key,
        Status: 'Concluído',
        Descricao: item.Descricao || existing.Descricao || {},
        CriadoEm: criadoEm,
        Summary: item.Summary || existing.Summary || '',
        firstSeen: existing.firstSeen || new Date().toISOString()
      });
      activeAlerts.delete(payloadKey);
    }
  });

  let ativos = Array.from(activeAlerts.values());
  console.log("Total de alertas abertos antes do filtro:", ativos.length);

  // aplica filtro por setor só se SETOR_USUARIO existir
  if (setorUsuarioRaw) {
    // se temos a lista de controladores do setor, usa os serials para filtrar
    if (controladoresSetor && controladoresSetor.length) {
      const serialSet = new Set(controladoresSetor.map(c => normalizeSerialForCompare(c.numero_serial)));
      const filtrados = ativos.filter(a => serialSet.has(normalizeSerialForCompare(a.Descricao?.Maquina || '')));
      console.log("Alertas após filtro de setor (por serials):", filtrados.length, " | Setor usuário:", setorUsuarioRaw);
      if (filtrados.length > 0) {
        ativos = filtrados;
      }
    } else {
      // fallback: tenta comparar pelo nome do setor (caso SETOR_USUARIO contenha o nome)
      const filtrados = ativos.filter(a => norm(a.Descricao?.Setor || "") === setorUsuarioNorm);
      console.log("Alertas após filtro de setor (por nome fallback):", filtrados.length, " | Setor usuário:", setorUsuarioRaw);
      if (filtrados.length > 0) ativos = filtrados;
    }
  } else {
    console.warn("SETOR_USUARIO não definido no sessionStorage. Mostrando todos os setores.");
  }

  if (controladorFiltroSelecionado !== "Todos") {
    ativos = ativos.filter(a => serialEquals(a.Descricao?.Maquina, controladorFiltroSelecionado));
    resolvidosHoje = resolvidosHoje.filter(a => serialEquals(a.Descricao?.Maquina, controladorFiltroSelecionado));
  }

  // Garante que a opção 'Todos' mostre apenas controladores do setor do usuário
  if (controladorFiltroSelecionado === "Todos" && setorUsuarioRaw) {
    if (controladoresSetor && controladoresSetor.length) {
      const serialSetUsuario = new Set(controladoresSetor.map(c => normalizeSerialForCompare(c.numero_serial)));
      ativos = ativos.filter(a => serialSetUsuario.has(normalizeSerialForCompare(a.Descricao?.Maquina || '')));
      resolvidosHoje = resolvidosHoje.filter(a => serialSetUsuario.has(normalizeSerialForCompare(a.Descricao?.Maquina || '')));
      console.log("Aplicado filtro 'Todos' pelo setor do usuário. Alertas após filtro:", ativos.length);
    }
  }

  console.log("Alertas considerados para dashboard (após todos filtros):", ativos.length);

  atualizarKPI(ativos);

  const feed = document.getElementById('feed_area');
  feed.innerHTML = '';

  ativos.forEach(item => {
    const hora = formatHoraFrom(item);
    const mensagem = `${item.Summary || 'Alerta'} - ${item.Descricao?.Maquina || 'N/A'}`;
    const criticidade = norm(item.Descricao?.Criticidade || '');
    const div = document.createElement('div');

    div.className =
      criticidade === 'CRITICO' ? 'feed-item critico' :
      criticidade === 'MEDIO'  ? 'feed-item medio'   :
                                 'feed-item estavel';

    div.innerHTML = `<div>${mensagem}</div><div>${hora}</div>`;
    feed.appendChild(div);
  });

  resolvidosHoje.forEach(item => {
    const hora = formatHoraFrom(item);
    const mensagem = `Resolvido - ${item.Summary || 'Alerta'} - ${item.Descricao?.Maquina || 'N/A'}`;
    const div = document.createElement('div');
    div.className = 'feed-item resolvido';
    div.innerHTML = `<div>${mensagem}</div><div>${hora}</div>`;
    feed.appendChild(div);
  });

  document.getElementById('kpi_resolvidos').innerText = resolvidosHoje.length;

  atualizarGraficoPorComponentePorHora(ativos, 12);
  ultimoLoteAlertas = dados;
  tentarAtualizarHeatmap();
}

function atualizarGraficoPorComponentePorHora(lista, janelaHoras = 12) {
  const now = new Date();
  const labels = [];

  for (let i = janelaHoras - 1; i >= 0; i--) {
      const dt = new Date(now.getTime() - i * 3600 * 1000);
      dt.setMinutes(0, 0, 0, 0); // normalize to start of the hour
      labels.push({ label: String(dt.getHours()).padStart(2, '0') + ':00', hora: dt });
  }

  const cpu = Array(labels.length).fill(0);
  const ram = Array(labels.length).fill(0);
  const disco = Array(labels.length).fill(0);

  lista.forEach(alerta => {
      const inicio = parseDateString(alerta.CriadoEm || alerta.firstSeen);
      if (isNaN(inicio.getTime())) return;
      const fim = alerta.ConcluidoEm ? parseDateString(alerta.ConcluidoEm) : null;

    labels.forEach((slot, idx) => {
        const slotStart = slot.hora;
        const slotEnd = new Date(slotStart.getTime() + 3600 * 1000);
        const ativo = (inicio < slotEnd) && (!fim || fim >= slotStart);
      if (!ativo) return;

      const comp = norm(alerta.Descricao?.Componente || '');
      if (comp.includes('CPU')) cpu[idx]++;
      else if (comp.includes('RAM')) ram[idx]++;
      else if (comp.includes('DISCO') || comp.includes('DISK')) disco[idx]++;
    });
  });

  graficoComponentes.data.labels = labels.map(l => l.label);
  graficoComponentes.data.datasets[0].data = cpu;
  graficoComponentes.data.datasets[1].data = ram;
  graficoComponentes.data.datasets[2].data = disco;
  graficoComponentes.update();
}

anychart.onDocumentReady(function () {
  heatmapChart = anychart.heatMap([]);
  const colorScale = anychart.scales.ordinalColor();

  colorScale.ranges([
    { from: 0, to: 0, color: "#4CAF50" },
    { from: 1, to: 1, color: "#e6ac00" },
    { from: 2, to: 2, color: "#E71831" }
  ]);

  heatmapChart.colorScale(colorScale);
  heatmapChart.labels(false);
  heatmapChart.tooltip().useHtml(true);
  heatmapChart.container("container");
  heatmapChart.draw();
});

function tentarAtualizarHeatmap() {
  if (!heatmapChart || !ultimoLoteAlertas || !controladoresSetor.length) return;
  atualizarHeatmap(ultimoLoteAlertas, 12);
}

function atualizarHeatmap(dadosAlertas, janelaHoras = 12) {
  const setorUsuarioRaw = sessionStorage.getItem("SETOR_USUARIO") || "";
  const setorUsuarioNorm = setorUsuarioRaw ? norm(setorUsuarioRaw) : null;

  const agora = new Date();
  const slots = [];

  for (let i = janelaHoras - 1; i >= 0; i--) {
    const dt = new Date(agora.getTime() - i * 3600 * 1000);
    dt.setMinutes(0, 0, 0, 0); // normalize to start of the hour
    slots.push({ label: String(dt.getHours()).padStart(2, '0') + ':00', date: dt });
  }

  const dataHeat = [];

  controladoresSetor.forEach(ctrl => {
    const serial = ctrl.numero_serial;
    slots.forEach(slot => {
      let melhorCodigo = 0;
      let melhorAlerta = null;

      dadosAlertas.forEach(alerta => {
        if (!alerta.Descricao) return;
        if (!serialEquals(alerta.Descricao.Maquina, serial)) return;

        if (setorUsuarioRaw) {
          if (controladoresSetor && controladoresSetor.length) {
            const serialSet = new Set(controladoresSetor.map(c => normalizeSerialForCompare(c.numero_serial)));
            if (!serialSet.has(normalizeSerialForCompare(alerta.Descricao.Maquina || ''))) return;
          } else {
            const setorAlertaNorm = norm(alerta.Descricao.Setor || "");
            if (setorAlertaNorm !== setorUsuarioNorm) return;
          }
        }

          const inicio = parseDateString(alerta.CriadoEm || alerta.firstSeen);
          if (isNaN(inicio.getTime())) return;
          const fim = alerta.ConcluidoEm ? parseDateString(alerta.ConcluidoEm) : null;

          const slotStart = slot.date;
          const slotEnd = new Date(slotStart.getTime() + 3600 * 1000);
          const ativo = (inicio < slotEnd) && (!fim || fim >= slotStart);
          if (!ativo) {
            if (DEBUG_HEATMAP) {
              console.debug('[HEATMAP] alerta não ativo para slot', slot.label,
                'controlador=', serial,
                'inicio=', inicio.toISOString(),
                'fim=', fim ? fim.toISOString() : null,
                'slotStart=', slotStart.toISOString(),
                'slotEnd=', slotEnd.toISOString());
            }
            return;
          }

        const critStr = norm(alerta.Descricao.Criticidade || '');
        let code = 0;
        if (critStr === 'MEDIO') code = 1;
        else if (critStr === 'CRITICO') code = 2;

        if (code > melhorCodigo) {
          melhorCodigo = code;
          melhorAlerta = alerta;
        }
      });

      if (DEBUG_HEATMAP && melhorCodigo > 0) {
        console.debug('[HEATMAP] encontrou melhorCodigo>', melhorCodigo,
          'controlador=', serial,
          'slot=', slot.label,
          'melhorAlerta.Maquina=', melhorAlerta?.Descricao?.Maquina,
          'crit=', melhorAlerta?.Descricao?.Criticidade,
          'inicio=', melhorAlerta?.CriadoEm || melhorAlerta?.firstSeen,
          'fim=', melhorAlerta?.ConcluidoEm);
      }

      let critLabel = 'Estável';
      if (melhorCodigo === 1) critLabel = 'Média';
      else if (melhorCodigo === 2) critLabel = 'Crítica';

      dataHeat.push({
        x: slot.label,
        y: "Controlador " + serial,
        heat: melhorCodigo,
        critLabel: critLabel,
        controlador: serial,
        valorAtual: melhorAlerta?.Descricao?.ValorAtual || null,
        tooltip: `Controlador: ${serial}<br>Hora: ${slot.label}<br>Valor atual: ${melhorAlerta?.Descricao?.ValorAtual || 'Sem alerta'}`
      });
    });
  });

  heatmapChart.data(dataHeat);

  heatmapChart.tooltip()
    .useHtml(true)
    .titleFormat(function () {
      return this.getData('critLabel') || 'Estável';
    })
    .format(function () {
      return this.getData('tooltip');
    });
}

criarGraficoComponentes();

(async function inicializarDashboard() {
  controladoresSetor = await buscarControladores();
  if (!controladoresSetor.length) {
    console.warn("Nenhum controlador retornado do setor, usando mock.");
    controladoresSetor = [
      { id_controlador: 1, numero_serial: "0001" },
      { id_controlador: 2, numero_serial: "0002" },
      { id_controlador: 3, numero_serial: "0003" }
    ];
  }

  popularSelectControladores();

  // busca e exibe nome do setor do usuário (se disponível)
  async function mostrarNomeSetor() {
    const setorId = sessionStorage.getItem('SETOR_USUARIO');
    if (!setorId) return;
    try {
      const resp = await fetch('/cpuRam/buscarNomeSetor', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ setor: setorId })
      });
      if (!resp.ok) return;
      const dados = await resp.json();
      if (Array.isArray(dados) && dados[0] && dados[0].nome) {
        document.getElementById('label-setor').innerText = 'Setor: ' + dados[0].nome;
      }
    } catch (e) {
      console.warn('Não foi possível buscar nome do setor:', e);
    }
  }

  mostrarNomeSetor();

  async function carregarAlertas() {
    try {
      const resposta = await fetch('/s3RouteAlertasTempoReal/dados/ultimo');
      console.log("Resposta fetch alertas S3:", resposta);
      if (!resposta.ok) throw new Error("Erro ao buscar alertas do S3");
      let dados = await resposta.json();

      if (!Array.isArray(dados)) {
        if (dados.alertas && Array.isArray(dados.alertas)) {
          dados = dados.alertas;
        } else {
          dados = [];
        }
      }
      usarDadosReais(dados);
    } catch (erro) {
      console.error("Erro ao carregar alertas:", erro);
    }
  }

  carregarAlertas();
  setInterval(carregarAlertas, 30 * 1000);
})();
</script>



</body>

</html>
